#!/bin/sh

# XXX: ideas:
# - compression
# - custom zfsync zfs properties
# - recursive sending
# - check for large_blocks and use it if present

# halt on error
set -e
# get rid of locale
unset LC_ALL
unset LANG
# force PATH
PATH=${PATH}:/bin:/usr/bin:/usr/local/bin:/sbin:/usr/sbin:/usr/local/sbin

if [ -f "./lib/common" ]; then
    LIB="./lib"
elif [ -d "/usr/local/lib/zfsync" ]; then
    LIB="/usr/local/lib/zfsync"
else
    echo "ERROR: required libraries not found"
    exit 1
fi

. "${LIB}/common"
. "${LIB}/ssh"
. "${LIB}/zfs"
. "${LIB}/zpool"

# parse command line
if [ $# -eq 0 ]; then
    zf_usage
    exit 1
fi

# set some defaults
ZF_DEBUG=0
ZF_SILENT=0
ZF_INCREMENTAL=0
ZF_LARGE_BLOCKS=0

while getopts 'dhH:iI:qT:U:' opt; do
    case ${opt} in
        d) ZF_DEBUG=1;;
        h)
            zf_usage
            exit 0
            ;;
        H) ZF_TARGET_HOST=${OPTARG};;
        i) ZF_INCREMENTAL=1;;
        I) ZF_IDENTITY_FILE=${OPTARG};;
        q) ZF_SILENT=1;;
        T) ZF_TARGET_ZFS=${OPTARG%/};;
        U) ZF_TARGET_USER=${OPTARG};;
        ?)
            zf_usage
            exit 1
            ;;
    esac
done
shift "$((OPTIND - 1))"

ZF_SOURCE_ZFS=${1%/}

# defaults and parameter checking
[ -z "${ZF_TARGET_USER}" ] && ZF_TARGET_USER="${USER}"
[ -z "${ZF_TARGET_HOST}" ] && zf_usage "no target ZFS specified"
[ -z "${ZF_SOURCE_ZFS}" ] && zf_usage "no source ZFS specified"

# determine if we can use -L during sending
if zf_zpool_has_feature "large_blocks" && \
    zf_zpool_has_feature "large_blocks" 1; then
    zf_msg "Using large blocks while sending"
    ZF_LARGE_BLOCKS=1
fi

# sanity check
zf_msg "Checking source and target"
if ! zf_zfs_exists "${ZF_SOURCE_ZFS}"; then
    zf_error "source ZFS not found"
fi

if ! zf_zfs_exists "${ZF_TARGET_ZFS}" 1; then
    zf_error "target ZFS not found"
fi

# permissions check
zf_msg "Checking permissions on source and target"
if ! zf_zfs_is_user_allowed "${USER}" "hold,send" "${ZF_SOURCE_ZFS}"; then
   zf_error "${USER} is not allowed to send ${ZF_SOURCE_ZFS}"
fi

# TODO: what if the other side is not mounted
if ! zf_zfs_is_user_allowed "${ZF_TARGET_USER}" "receive,create,mount,userprop" "${ZF_TARGET_ZFS}" 1; then
   zf_error "${ZF_TARGET_USER} is not allowed to receive on ${ZF_TARGET_ZFS}"
fi

# look for matching snapshots
if ! zf_zfs_has_matching_snapshots "${ZF_SOURCE_ZFS}" "${ZF_TARGET_ZFS}"; then
    zf_warn "no matching snapshots between source and target"
    oldest_snapshot=$(zf_zfs_snapshots "${ZF_SOURCE_ZFS}" | head -1)
    # get oldest source snapshot for initial sync
    if [ -z "${oldest_snapshot}" ]; then
        zf_error "source ${ZF_SOURCE_ZFS} has no snapshots"
    fi

    # perform initial sync
    # TODO: fix basename stuff
    zf_msg "Sending initial snapshot ${oldest_snapshot}"
    zf_zfs_sync "${ZF_SOURCE_ZFS}${oldest_snapshot}" "${ZF_TARGET_ZFS}/$(basename ${ZF_SOURCE_ZFS})"

    zf_msg "Checking both sides again for matches"
fi

# perform incremental sync
latest_match=$(zf_zfs_matching_snapshots "${ZF_SOURCE_ZFS}" "${ZF_TARGET_ZFS}" | tail -1)
if [ -z "${latest_match}" ]; then
    zf_error "no matches found between ${ZF_SOURCE_ZFS} and ${ZF_TARGET_ZFS}"
fi

zf_debug "found matching snapshot ${latest_match}"
latest_snapshot=$(zf_zfs_snapshots "${ZF_SOURCE_ZFS}" | tail -1)
if [ "${latest_match}" = "${latest_snapshot}" ]; then
    zf_msg "Both ends are in sync"
    return
fi

zf_msg "Sending incremental from ${latest_match} to ${latest_snapshot}"
# TODO: make -R optional
[ ${ZF_INCREMENTAL} -eq 1 ] && cmd_inc="-i" || cmd_inc="-I"
zf_zfs_sync "${ZF_SOURCE_ZFS}${latest_snapshot}" "${ZF_TARGET_ZFS}/$(basename ${ZF_SOURCE_ZFS})" "-R ${cmd_inc} ${latest_match}"
zf_msg "Done"
